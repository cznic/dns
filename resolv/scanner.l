%{
// Copyright (c) 2011 CZ.NIC z.s.p.o. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// blame: jnml, labs.nic.cz


// WARNING: If this file is scanner.go then DO NOT EDIT.
// scanner.go is generated by golex from scanner.l (see the Makefile).


package resolv


import (
	"errors"
	"fmt"
	"io"
	"net"
	"strconv"
	"strings"
	"unicode"
)


type lex struct {
	resolv    *Conf
	startCond int
	buf       []byte
	peek      byte
	line      int
	column    int
	name      string
	src       *strings.Reader
}


func (l *lex) getc(c byte) byte {
	if c != 0 {
		l.buf = append(l.buf, c)
	}
	if b, err := l.src.ReadByte(); err == nil {
		l.peek = b
		if b == '\n' {
			l.line++
			l.column = 0
		} else {
			l.column++
		}
		return b
	} else {
		if err == io.EOF {
			l.peek = 0
			return 0
		}
		panic(err)
	}

	panic("unreachable")
}


func newLex(name string, source *strings.Reader) (l *lex) {
	l = &lex{}
	l.resolv = NewConf()
	l.line = 1
	l.name = name
	l.src = source
	l.begin(sc_LINE_START)
	l.getc(0)
	return
}


func (l *lex) Error(e string) {
	panic(errors.New(e))
}


func (l *lex) begin(sc int) {
	l.startCond = sc
}


const (
	sc_INITIAL = iota
	sc_LINE_START
	sc_IP
	sc_DOMAIN
	sc_OPTS
)


func (l *lex) Lex(lval *yySymType) (ret int) {
	c := l.peek
	ret = -1
%}

%yyt l.startCond
%yyc c
%yyn c = l.getc(c)

%x lineStart ip domain
%x opts

ip_address {ipv6}|{ipv4}
byte       {digit}{digit}?{digit}?
digit      [0-9]
hex        [0-9a-fA-F]
hex4       {hex}{hex}?{hex}?{hex}?
hexpart    {hexseq}|{hexseq}"::"{hexseq}?|"::"{hexseq}?
hexseq     {hex4}(":"{hex4})*
ipv4       {byte}"."{byte}"."{byte}"."{byte}
ipv6       {hexpart}

hostname       {name}("."{name})*
let_or_digit   [a-zA-Z0-9]
name           {let_or_digit}(({let_or_digit}|"-")*{let_or_digit})?

%%
	if ret >= 0 {
		lval.str = string(l.buf)
		return
	}

	l.buf = l.buf[:0]

<lineStart>[ \t]+      l.begin(0)
<lineStart>domain      return tDOMAIN
<lineStart>nameserver  return tNAMESERVER
<lineStart>options     return tOPTIONS
<lineStart>search      return tSEARCH
<lineStart>sortlist    return tSORTLIST

<ip>{ip_address}
	ip := net.ParseIP(string(l.buf))
	if ip == nil {
		panic(fmt.Errorf("invalid IP %q", l.buf))
	}
	lval.ip = ip
	return tIP_ADDRESS

<domain>{hostname}     ret = tDOMAIN_NAME

<opts>attempts         return tATTEMPTS
<opts>debug            return tDEBUG
<opts>edns0            return tEDNS0
<opts>inet6            return tINET6
<opts>ip6-bytestring   return tIP6_BYTESTRING
<opts>ip6-dotint       return tIP6_DOTINT
<opts>ndots            return tNDOTS
<opts>no-check-names   return tNO_CHECK_NAMES
<opts>no-ip6-dotint    return tNO_IP6_DOTINT
<opts>rotate           return tROTATE
<opts>timeout          return tTIMEOUT

<opts>[ \t]*:[ \t]*
	return ':'

<opts>[0-9]+
	var err error
	var n64 uint64
	n64, err = strconv.ParseUint(string(l.buf), 10, 0)
	lval.num = uint(n64)
	if err == nil {
		return tDECADIC
	}

	panic(fmt.Errorf("invalid number %q", string(l.buf)))

<*>[ \t]+
	if c != '\n' { // field sep
		return ' '
	}

<*>[ \t]*#.*

%%
	// fail
	if len(l.buf) == 0 {
		ret = int(c)
		l.getc(0)
		return
	}

	return unicode.ReplacementChar
}

