%{
// Copyright (c) 2011 CZ.NIC z.s.p.o. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// blame: jnml, labs.nic.cz


// WARNING: If this file is parser.go then DO NOT EDIT.
// parser.go is generated by goyacc from parser.y (see the Makefile).


package zone


import (
	"github.com/cznic/dns"
	"github.com/cznic/dns/rr"
	"github.com/cznic/strutil"
	"fmt"
	"math"
	"net"
)


type rrHead struct{
	ttl   int32
	class rr.Class
}

%}

%union{
	alg    rr.AlgorithmType
	class  rr.Class
	data   []byte
	str    string
	u64    uint64
	int    int
	uint   uint
	ip     net.IP
	rrh    rrHead
	rrData dns.Wirer
	rr     *rr.RR
	typ    rr.Type
	types  []rr.Type
}


%token
	tDLR_TTL

	tBLANK_START
	tA
	tAAAA
	tA6
	tAFSDB
	tAPL
	tATMA
	tCERT
	tCDS
	tCNAME
	tDNAME
	tDHCID
	tDNSKEY
	tDS
	tEID
	tGID
	tGPOS
	tHINFO
	tHIP
	tIPSECKEY
	tISDN
	tKEY
	tKX
	tLOC
	tMX
	tNAPTR
	tNIMLOC
	tNINFO
	tNSAP
	tNSAP_PTR
	tNS
	tNSEC
	tNSEC3
	tNSEC3PARAM
	tNXT
	tPTR
	tPX
	tRKEY
	tRP
	tRRSIG
	tRT
	tSIG
	tSOA
	tSPF
	tSRV
	tSSHFP
	tTALINK
	tTKEY
	tTSIG
	tTXT
	tUID
	tUINFO
	tUNSPEC
	tWKS
	tX25

%token <data>
	tHEX

%token <str>
	tBASE32EXT
	tBASE64
	tDOMAIN_NAME
	tQSTR

%token <class>
	tCLASS

%token <ip>
	tIPV4
	tIPV6

%token <u64>
	tDECADIC

%type <alg>
	alg

%type <data>
	base32ext
	base64
	hex

%type <int>
	ttl
	uint31

%type <rrData>
	a
	aaaa
	cname
	dname
	dnskey
	ds
	mx
	ns
	nsec3
	nsec3param
	ptr
	rrsig
	soa
	txt

%type <rr>
	rr
	rr2

%type <rrh>
	rrHead

%type <str>
	base64str
	txt2

%type <typ>
	rrtype
	rrtypetok

%type <types>
	rrtypes

%type <u64>
	dtg

%type <uint>
	dtg32
	uint8
	uint16
	uint32

%left notQSTR
%left tQSTR

%%

goal:
	line
|	goal line


a:
 	tA
 	{
		yylex.begin(sc_IPV4)
	}
	tIPV4
	{
		$$ = &rr.A{$3}
	}


aaaa:
 	tAAAA
 	{
		yylex.begin(sc_IPV6)
	}
	tIPV6
	{
		$$ = &rr.AAAA{$3}
	}


alg:
	uint8
	{
		$$ = rr.AlgorithmType($1)
	}


base32ext:
	{
		yylex.begin(sc_BASE32EXT)
	}
	tBASE32EXT
	{
		yylex.begin(sc_INITIAL)
		if data, err := strutil.Base32ExtDecode([]byte($2)); err != nil {
			yylex.Error(err.Error())
		} else {
			$$ = data
		}
	}


base64:
	base64str '\n'
	{
		yylex.begin(sc_INITIAL)
		if data, err := strutil.Base64Decode([]byte($1)); err != nil {
			yylex.Error(err.Error())
		} else {
			$$ = data
		}
	}


base64str:
	{
		yylex.begin(sc_BASE64)
	}
	tBASE64
	{
		$$ = $2
	}
|	base64str tBASE64
	{
		$$ += $2
	}


cname:
	tCNAME
	{
		yylex.begin(sc_DOMAIN)
	}
	tDOMAIN_NAME
	{
		$$ = &rr.CNAME{$3}
	}


dname:
	tDNAME
	{
		yylex.begin(sc_DOMAIN)
	}
	tDOMAIN_NAME
	{
		$$ = &rr.DNAME{$3}
	}


dnskey:
	tDNSKEY uint16 uint8 alg
	{
		if $3 != 3 {
			yylex.Error(`protocol must be "3"`)
		}
	}
	base64
	{
		$$ = &rr.DNSKEY{uint16($2), byte($3), $4, $6}
	}


ds:
	tDS
	{
		yylex.begin(sc_NUM)
	}
	uint16 uint8 uint8 hex
	{
		if $5 != 1 || len($6) != 20 {
			yylex.Error(`digest type must be "1" and digest must be exactly 20 bytes (40 hex chars)`)
		} else {
			$$ = &rr.DS{uint16($3), rr.AlgorithmType($4), rr.HashAlgorithm($5), $6}
		}
	}


dtg:
	tDECADIC
	{
		if t, err := dns.String2Seconds($<str>1); err != nil {
			yylex.Error(err.Error())
		} else {
			$$ = uint64(t)
		}
	}


dtg32:
	dtg
	{
		$$ = uint($1)
	}


hex:
	{
		yylex.begin(sc_HEX)
	}
	tHEX
	{
		$$ = $2
	}


line:
	'\n'
	{
		yylex.begin(sc_INITIAL)
	}
|	tDLR_TTL
	{
		yylex.begin(sc_NUM)
	}
	ttl
|	tDOMAIN_NAME
	{
		yylex.begin(sc_RRHEAD)
	}
	rr
	{
		$3.Name = $1
		if !yylex.rrHandler($3) {
			goto ret0
		}
	}
|	tBLANK_START rr
	{
		if !yylex.rrHandler($2) {
			goto ret0
		}
	}
|	'@' rr
	{
		$2.Name = "@"
		if !yylex.rrHandler($2) {
			goto ret0
		}
	}


mx:
	tMX
	{
		yylex.begin(sc_NUM)
	}
	uint16
	{
		yylex.begin(sc_DOMAIN)
	}
	tDOMAIN_NAME
	{
		$$ = &rr.MX{uint16($3), $5}
	}


ns:
  	tNS
	{
		yylex.begin(sc_DOMAIN)
	}
	tDOMAIN_NAME
	{
		$$ = &rr.NS{$3}
	}


nsec3:
	tNSEC3
	{
		yylex.begin(sc_NUM)
	}
	uint8 uint8 uint16 hex base32ext
	{
		yylex.begin(sc_TYPE)
	}
	rrtypes
	{
		$$ = &rr.NSEC3{rr.NSEC3PARAM{rr.HashAlgorithm($3), byte($4), uint16($5), $6}, $7, rr.TypesEncode($9)}
	}


nsec3param:
	tNSEC3PARAM
	{
		yylex.begin(sc_NUM)
	}
	uint8 uint8 uint16 hex
	{
		$$ = &rr.NSEC3PARAM{rr.HashAlgorithm($3), byte($4), uint16($5), $6}
	}


ptr:
   	tPTR
	{
		yylex.begin(sc_DOMAIN)
	}
	tDOMAIN_NAME
	{
		$$ = &rr.PTR{$3}
	}


rr:
	{
		yylex.begin(sc_RRHEAD)
	}
	rr2
	{
		$$ = $2
	}


rr2:
	rrHead a
	{
		$$ = &rr.RR{"", rr.TYPE_A, $1.class, $1.ttl, $2}
	}
|	rrHead aaaa
	{
		$$ = &rr.RR{"", rr.TYPE_AAAA, $1.class, $1.ttl, $2}
	}
|	rrHead cname
	{
		$$ = &rr.RR{"", rr.TYPE_CNAME, $1.class, $1.ttl, $2}
	}
|	rrHead dname
	{
		$$ = &rr.RR{"", rr.TYPE_DNAME, $1.class, $1.ttl, $2}
	}
|	rrHead dnskey
	{
		$$ = &rr.RR{"", rr.TYPE_DNSKEY, $1.class, $1.ttl, $2}
	}
|	rrHead ds
	{
		$$ = &rr.RR{"", rr.TYPE_DS, $1.class, $1.ttl, $2}
	}
|	rrHead mx
	{
		$$ = &rr.RR{"", rr.TYPE_MX, $1.class, $1.ttl, $2}
	}
|	rrHead ns
	{
		$$ = &rr.RR{"", rr.TYPE_NS, $1.class, $1.ttl, $2}
	}
|	rrHead nsec3
	{
		$$ = &rr.RR{"", rr.TYPE_NSEC3, $1.class, $1.ttl, $2}
	}
|	rrHead nsec3param
	{
		$$ = &rr.RR{"", rr.TYPE_NSEC3PARAM, $1.class, $1.ttl, $2}
	}
|	rrHead ptr
	{
		$$ = &rr.RR{"", rr.TYPE_PTR, $1.class, $1.ttl, $2}
	}
|	rrHead rrsig
	{
		$$ = &rr.RR{"", rr.TYPE_RRSIG, $1.class, $1.ttl, $2}
	}
|	rrHead soa
	{
		$$ = &rr.RR{"", rr.TYPE_SOA, $1.class, $1.ttl, $2}
	}
|	rrHead txt
	{
		$$ = &rr.RR{"", rr.TYPE_TXT, $1.class, $1.ttl, $2}
	}


rrHead:
	ttl tCLASS
	{
		$$ = rrHead{int32($1), $2}
	}
|	tCLASS ttl
	{
		$$ = rrHead{int32($2), $1}
	}
|	ttl
	{
		$$ = rrHead{int32($1), 0}
	}
|	tCLASS
	{
		$$ = rrHead{-1, $1}
	}


rrsig:
	tRRSIG rrtype
	{
		yylex.begin(sc_NUM)
	}
	alg uint8 ttl dtg32 dtg32 uint16
	{
		yylex.begin(sc_DOMAIN)
	}
	tDOMAIN_NAME base64
	{
		$$ = &rr.RRSIG{$2, $4, byte($5), int32($6), uint32($7), uint32($8), uint16($9), $11, $12}
	}


rrtype:
	{
		yylex.begin(sc_TYPE)
	}
	rrtypetok
	{
		$$ = $2
	}


rrtypes:
	'\n'
	{
		$$ = nil
		yylex.begin(sc_INITIAL)
	}
|	rrtype
	{
		$$ = []rr.Type{$1}
	}
|	rrtypes rrtype
	{
		$$ = append($$, $2)
	}


rrtypetok:
	tA
	{
		$$ = rr.TYPE_A
	}
|	tA6
	{
		$$ = rr.TYPE_A6
	}
|	tAAAA
	{
		$$ = rr.TYPE_AAAA
	}
|	tAFSDB
	{
		$$ = rr.TYPE_AFSDB
	}
|	tATMA
	{
		$$ = rr.TYPE_ATMA
	}
|	tAPL
	{
		$$ = rr.TYPE_APL
	}
|	tCDS
	{
		$$ = rr.TYPE_CDS
	}
|	tCERT
	{
		$$ = rr.TYPE_CERT
	}
|	tCNAME
	{
		$$ = rr.TYPE_CNAME
	}
|	tDHCID
	{
		$$ = rr.TYPE_DHCID
	}
|	tDNAME
	{
		$$ = rr.TYPE_DNAME
	}
|	tDNSKEY
	{
		$$ = rr.TYPE_DNSKEY
	}
|	tDS
	{
		$$ = rr.TYPE_DS
	}
|	tEID
	{
		$$ = rr.TYPE_EID
	}
|	tGID
	{
		$$ = rr.TYPE_GID
	}
|	tGPOS
	{
		$$ = rr.TYPE_GPOS
	}
|	tHINFO
	{
		$$ = rr.TYPE_HINFO
	}
|	tHIP
	{
		$$ = rr.TYPE_HIP
	}
|	tIPSECKEY
	{
		$$ = rr.TYPE_IPSECKEY
	}
|	tISDN
	{
		$$ = rr.TYPE_ISDN
	}
|	tKEY
	{
		$$ = rr.TYPE_KEY
	}
|	tKX
	{
		$$ = rr.TYPE_KX
	}
|	tLOC
	{
		$$ = rr.TYPE_LOC
	}
|	tMX
	{
		$$ = rr.TYPE_MX
	}
|	tNAPTR
	{
		$$ = rr.TYPE_NAPTR
	}
|	tNIMLOC
	{
		$$ = rr.TYPE_NIMLOC
	}
|	tNINFO
	{
		$$ = rr.TYPE_NINFO
	}
|	tNS
	{
		$$ = rr.TYPE_NS
	}
|	tNSAP
	{
		$$ = rr.TYPE_NSAP
	}
|	tNSAP_PTR
	{
		$$ = rr.TYPE_NSAP_PTR
	}
|	tNSEC
	{
		$$ = rr.TYPE_NSEC
	}
|	tNSEC3
	{
		$$ = rr.TYPE_NSEC3
	}
|	tNSEC3PARAM
	{
		$$ = rr.TYPE_NSEC3PARAM
	}
|	tNXT
	{
		$$ = rr.TYPE_NXT
	}
|	tPTR
	{
		$$ = rr.TYPE_PTR
	}
|	tPX
	{
		$$ = rr.TYPE_PX
	}
|	tRRSIG
	{
		$$ = rr.TYPE_RRSIG
	}
|	tRKEY
	{
		$$ = rr.TYPE_RKEY
	}
|	tRP
	{
		$$ = rr.TYPE_RP
	}
|	tRT
	{
		$$ = rr.TYPE_RT
	}
|	tSIG
	{
		$$ = rr.TYPE_SIG
	}
|	tSOA
	{
		$$ = rr.TYPE_SOA
	}
|	tSPF
	{
		$$ = rr.TYPE_SPF
	}
|	tSRV
	{
		$$ = rr.TYPE_SRV
	}
|	tSSHFP
	{
		$$ = rr.TYPE_SSHFP
	}
|	tTALINK
	{
		$$ = rr.TYPE_TALINK
	}
|	tTKEY
	{
		$$ = rr.TYPE_TKEY
	}
|	tTSIG
	{
		$$ = rr.TYPE_TSIG
	}
|	tTXT
	{
		$$ = rr.TYPE_TXT
	}
|	tUID
	{
		$$ = rr.TYPE_UID
	}
|	tUINFO
	{
		$$ = rr.TYPE_UINFO
	}
|	tUNSPEC
	{
		$$ = rr.TYPE_UNSPEC
	}
|	tWKS
	{
		$$ = rr.TYPE_WKS
	}
|	tX25
	{
		$$ = rr.TYPE_X25
	}


soa:
	tSOA
	{
		yylex.begin(sc_DOMAIN)
	}
	tDOMAIN_NAME tDOMAIN_NAME
	{
		yylex.begin(sc_NUM)
	}
	uint32 uint32 uint32 uint32 uint32 
	{
		$$ = &rr.SOA{$3, $4, uint32($6), uint32($7), uint32($8), uint32($9), uint32($10)}
	}


ttl:
	uint31


txt:
	tTXT txt2
	{
		$$ = &rr.TXT{$2}
	}


txt2:
	%prec notQSTR
	{
		$$ = "" 
	}
|	tQSTR
	{
		$$ = $1
	}
|	txt2 tQSTR
	{
		$$ += $2
	}


uint8:
	tDECADIC
	{
		if $1 > math.MaxUint8 {
			yylex.Error("number out of range")
			$$ = math.MaxUint8
		} else {
			$$ = uint($1)
		}
	}


uint16:
	tDECADIC
	{
		if $1 > math.MaxUint16 {
			yylex.Error("number out of range")
			$$ = math.MaxUint16
		} else {
			$$ = uint($1)
		}
	}


uint31:
	tDECADIC
	{
		if $1 > math.MaxInt32 {
			yylex.Error("number out of range")
			$$ = math.MaxInt32
		} else {
			$$ = int($1)
		}
	}


uint32:
	tDECADIC
	{
		if $1 > math.MaxUint32  {
			yylex.Error("number out of range")
			$$ = math.MaxUint32
		} else {
			$$ = uint($1)
		}
	}
