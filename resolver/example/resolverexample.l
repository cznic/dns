%{
// Copyright (c) 2011 CZ.NIC z.s.p.o. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// blame: jnml, labs.nic.cz


// WARNING: If this file is resolverexample.go then DO NOT EDIT.
// resolverexample.go is generated by golex from resolverexample.l (see the resolverexample.make makefile).


/* example query line
www.cnn.com www.wikipedia.org www.wikimedia.org www.apple.com www.slashdot.org www.microsoft.com www.seznam.cz www.idnes.cz www.gov.ru www.google.com www.google.cz mail.seznam.cz mail.seznam.com www.abclinuxu.cz www.whitehouse.gov www.nic.uk www.bbc.co.uk
*/
package main


import (
	"bufio"
	"cznic/dns"
	"cznic/dns/hosts"
	"cznic/dns/resolv"
	"cznic/dns/resolver"
	"cznic/dns/rr"
	"flag"
	"fmt"
	"log"
	"net"
	"os"
	"runtime"
	"strings"
	"time"
)


var (
	stdin    = bufio.NewReader(os.Stdin)
	stderr   = bufio.NewWriter(os.Stderr)
	buf      []byte
	current  byte
)


func getc() byte {
    if current != 0 {
        buf = append(buf, current)
    }
    current = 0
    if b, err := stdin.ReadByte(); err == nil {
        current = b
    }
    return current
}


func main() {

	defer func() {
		if e := recover(); e != nil {
			fmt.Fprintf(stderr, "%s: %s\n", os.Args[0], e.(error))
			stderr.Flush()
			os.Exit(1)
		}
	}()

	logLevelFlag := flag.Int("log", 0, "logging level 0 - 4")
	var dflag, eflag, tflag, vflag, helpFlag, preferIPv6 bool
	hostsname := hosts.Sys
	resolvname := resolv.Sys
	flag.BoolVar(&dflag, "d", false, "debug level logging")
	flag.BoolVar(&eflag, "e", false, "error level logging")
	flag.BoolVar(&tflag, "t", false, "trace level logging")
	flag.BoolVar(&vflag, "v", false, "verbose level logging")
	flag.BoolVar(&helpFlag, "help", false, "show usage help and quit")
	flag.StringVar(&hostsname, "h", hostsname, "where to load hosts from")
	flag.StringVar(&resolvname, "r", resolvname, "where to load resolv.conf from")
	flag.Parse()
	if flag.NArg() > 0 || helpFlag {
		fmt.Fprintln(stderr, "Example lookup of hostnames/IP addresses read from stdin.")
		fmt.Fprintf(stderr, "usage: %s [-h file] [-r file] [-e|-v|-t|-d|-log log_level]\n", os.Args[0])
		fmt.Fprintln(stderr, "\t-d\tdebug (same as -log 4)")
		fmt.Fprintln(stderr, "\t-e\tlog errors (same as -log 1)")
		fmt.Fprintln(stderr, "\t-h\thosts file")
		fmt.Fprintln(stderr, "\t-l\tlogging level 0 - 4")
		fmt.Fprintln(stderr, "\t-r\tresolv.conf file")
		fmt.Fprintln(stderr, "\t-t\ttrace (same as -log 3)")
		fmt.Fprintln(stderr, "\t-v\tverbose (same as -log 2)")
		fmt.Fprintln(stderr, "\t-help\tshow this and quit")
		fmt.Fprintln(stderr, "Specifying multiple log options causes undefined behaviour.")
		stderr.Flush()
		os.Exit(1)
	}

	if *logLevelFlag < 0 || *logLevelFlag > int(dns.LOG_DEBUG) {
		log.Fatalf("Invalid logging level %d, must be 0 - 4", *logLevelFlag)
	}

	logLevel := dns.LogLevel(*logLevelFlag)
	switch {
	case eflag:
		logLevel = dns.LOG_ERRORS
	case vflag:
		logLevel = dns.LOG_EVENTS
	case tflag:
		logLevel = dns.LOG_TRACE
	case dflag:
		logLevel = dns.LOG_DEBUG
	}
	r, err := resolver.New(hostsname, resolvname, dns.NewLogger(nil, logLevel))
	if err != nil {
		log.Fatal(err)
	}

	runtime.GOMAXPROCS(2)
	fmt.Println("Invoke with -? or -help for command line options help")
	fmt.Println("Enter ? for runtime help")
    c := getc() // init
%}

%yyc c
%yyn c = getc()

ip_address {ipv6}|{ipv4}
byte       {digit}{digit}?{digit}?
digit      [0-9]
hex        [0-9a-fA-F]
hex4       {hex}{hex}?{hex}?{hex}?
hexpart    {hexseq}|{hexseq}"::"{hexseq}?|"::"{hexseq}?
hexseq     {hex4}(":"{hex4})*
ipv4       {byte}"."{byte}"."{byte}"."{byte}
ipv6       {hexpart}

hostname       {name}("."{name})*\.?|\.
let_or_digit   [a-zA-Z0-9]
name           {let_or_digit}(({let_or_digit}|"-")*{let_or_digit})?

cmd        c|g|t

%%
    buf = buf[:0]

[ \t\n\r]+

\?[ \t]*$
	fmt.Println(`enter:
    [ query ... ]    (multiple queries on a line are executed in paralel)
        IP address   Invoke GetHostByAddr
        hostname     Invoke GetHostByName
    !4               Prefer A (IPv4) RRs in GetHostByName (default)
    !6               Prefer AAAA (IPv6) RRs in GetHostByName
    ?c domain        Show cached RRs for domain (non destructive)
    ?g domain        Get cached RRs for domain (process TTLs)
    ?t domain        Show the tree of cached RRs starting at domain (non destructive)
    ?                Show this help
    <EOF>            Exit program (ctrl-D at start of line)`)

!(4|6)[ ]*$
	preferIPv6 = buf[1] == '6'
	fmt.Printf("preferIPv6 is %t\n", preferIPv6)


\?{cmd}[ ]+{hostname}[ ]*$
	domain := dns.RootedName(strings.TrimSpace(string(buf[2:])))
	switch cmd := buf[1]; cmd {
	case 'c', 't':
		n := 0
		r.Cache().Enum(domain, func(path []string, data rr.Bytes) bool {
			n++
			if len(path) == 1 {
				path = append(path, "")
			}
			fmt.Printf("\n%s\n%s\n", strings.Join(path, "/"), data.Unpack())
			return cmd == 't'
		})
		fmt.Printf(">>> %s %q nodes: %d\n", string(cmd), domain, n)
	case 'g':
		if found, hit := r.Cache().Get(domain); hit {
			fmt.Printf(">>> cached items for %q\n%s\n", domain, found)
		} else {
			fmt.Printf("!!! nothing cached for %q\n", domain)
		}
	}

\?.*$
	fmt.Printf("command syntax error %q\n", buf)

{ip_address}
	go func(s string) {
		ip := net.ParseIP(s)
		t0 := time.Now()
		hosts, err := r.GetHostByAddr(ip)
		t1 := time.Now()
		var y string
		if err != nil {
			y = fmt.Sprintf("!!! GetHostByAddr(%q): %s", s, err)
		} else {
			y = fmt.Sprintf(">>> %q %s", s, hosts)
		}
		fmt.Printf("%s t = %.3g s\n", y, float64(t1.Sub(t0))/1e9)
	}(string(buf))

{hex4}|{hostname}
	go func(name string) {
		t0 := time.Now()
		ipList, cnames, err := r.GetHostByName(name, preferIPv6)
		t1 := time.Now()
		var y string
		if err != nil {
			y = fmt.Sprintf("!!! GetHostByName(%q): %s", name, err)
		} else {
			y = fmt.Sprintf(">>> %q", name)
			for _, cn := range cnames {
				y += fmt.Sprintf(" -> %s", cn.RData.(*rr.CNAME).Name)
			}
			y += fmt.Sprintf(" %s", ipList)
		}
		fmt.Printf("%s t = %.3g s\n", y, float64(t1.Sub(t0))/1e9)
	}(string(buf))


\0
	return // Exit on EOF or any other input error

[^ \t\n\r]+
	fmt.Printf("unrecognized token %q ignored\n", buf)

%%
	fmt.Printf("syntax error %q\n", buf)
	goto yystate0
}
